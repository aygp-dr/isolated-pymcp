#+TITLE: Comprehensive Two-Day Claude Code Course
#+AUTHOR: daidaitaotao
#+DATE: 2025-04-22
#+OPTIONS: toc:3 num:t
#+PROPERTY: header-args :eval never-export

* Introduction
:PROPERTIES:
:CUSTOM_ID: introduction
:END:

This course provides a comprehensive introduction to Claude Code, covering everything from basic setup to advanced usage patterns. The course is designed to be completed in two days, but sections can be taken independently based on your needs and interests.

** Purpose and Scope
:PROPERTIES:
:CUSTOM_ID: purpose-and-scope
:END:

- Learn how to effectively use Claude Code for software development
- Understand different deployment options (Anthropic API, AWS Bedrock)
- Master code review, PR, and summarization workflows
- Create and use custom Claude commands
- Integrate with Model Context Protocol (MCP)
- Apply best practices from Anthropic's engineering team

** Prerequisites
:PROPERTIES:
:CUSTOM_ID: prerequisites
:END:

- Basic understanding of Python programming
- Familiarity with Git and GitHub
- Access to Anthropic API key or AWS Bedrock
- Linux, macOS, or Windows with WSL environment

* Day 1: Getting Started with Claude Code
:PROPERTIES:
:CUSTOM_ID: day-1
:END:

** Setting Up Claude with Anthropic API
:PROPERTIES:
:CUSTOM_ID: anthropic-api-setup
:END:

*** Installation and Configuration
:PROPERTIES:
:CUSTOM_ID: installation-and-configuration
:END:

To get started with Claude Code, you'll need to install the CLI tool and configure it:

1. Install Claude Code:
   #+begin_src shell
   # Install using npm
   npm install -g @anthropic-ai/claude-code
   
   # Verify installation
   claude --version
   #+end_src

2. Configure with your Anthropic API key:
   #+begin_src shell
   # Set API key (replace with your actual key)
   claude config set api_key sk-ant-xxxx
   
   # Or use environment variable
   export ANTHROPIC_API_KEY=sk-ant-xxxx
   #+end_src

3. Configure GitHub authentication:
   #+begin_src shell
   # Authenticate with GitHub CLI
   gh auth login
   #+end_src
   
   When prompted:
   - Select GitHub.com
   - Choose HTTPS protocol
   - Select Yes for authenticating Git with GitHub credentials
   - Choose "Paste an authentication token"
   - Generate a token at https://github.com/settings/tokens/new with these scopes:
     - repo
     - workflow
     - admin:org
     - gist
     - user
     - project
     - admin:gpg_key
   - Paste your token when prompted

*** API Key Management
:PROPERTIES:
:CUSTOM_ID: api-key-management
:END:

Proper API key management is crucial for security:

1. Use environment variables when possible:
   #+begin_src shell
   # Set temporarily
   export ANTHROPIC_API_KEY=sk-ant-xxxx
   
   # Add to your shell profile for persistence
   echo 'export ANTHROPIC_API_KEY=sk-ant-xxxx' >> ~/.bashrc
   source ~/.bashrc
   #+end_src

2. Avoid hardcoding API keys in scripts:
   #+begin_src python
   # Good practice
   import os
   api_key = os.environ.get("ANTHROPIC_API_KEY")
   if not api_key:
       raise ValueError("ANTHROPIC_API_KEY not set")
   #+end_src

3. Use a credential manager or secret vault for team environments

4. Rotate API keys periodically for better security

*** Basic Usage Patterns
:PROPERTIES:
:CUSTOM_ID: basic-usage-patterns
:END:

Get familiar with these common Claude Code usage patterns:

1. Basic code analysis:
   #+begin_src shell
   # Analyze a file
   claude analyze app.py
   
   # Analyze a specific function
   claude analyze app.py:main_function
   
   # Summarize an entire codebase as a diagram
   claude "Summarize this codebase as a Mermaid diagram"
   #+end_src

2. Generating code:
   #+begin_src shell
   # Generate a function
   claude "Write a function that converts celsius to fahrenheit"
   
   # Create a new file
   claude "Create a basic Express.js server with two routes"
   #+end_src

3. Using slash commands:
   #+begin_src shell
   # Get help
   claude /help
   
   # Explain a concept
   claude /explain "What are Python decorators?"
   
   # Improve code quality
   claude /refactor app.py
   #+end_src

4. Troubleshooting common issues:
   - If you see "Could not download model-context-protocol", check your network connection and try again
   - For authentication issues, verify your API key is correctly set
   - If Claude Code seems unresponsive, check your terminal's proxy settings

*** Exercise: Setting Up Your First Project
:PROPERTIES:
:CUSTOM_ID: exercise-first-project
:END:

In this hands-on exercise, you'll:
1. Install and configure Claude Code with your API key
2. Set up GitHub authentication
3. Clone a sample repository
4. Run basic Claude Code commands to analyze the codebase
5. Create a simple utility function with Claude's help

** Claude on AWS Bedrock
:PROPERTIES:
:CUSTOM_ID: bedrock-setup
:END:

*** AWS Setup and IAM Configuration
:PROPERTIES:
:CUSTOM_ID: aws-setup
:END:

To run Claude Code with AWS Bedrock, you'll need to configure the appropriate IAM permissions:

1. Add the ~AmazonBedrockFullAccess~ policy to your IAM user or role
   - Navigate to: https://us-east-1.console.aws.amazon.com/iam/home?region=us-east-2#/policies/details/arn%3Aaws%3Aiam%3A%3Aaws%3Apolicy%2FAmazonBedrockFullAccess
   - Attach this policy to your IAM user/role

2. Configure your AWS credentials locally:
   #+begin_src shell
   aws configure
   # Enter your AWS Access Key ID
   # Enter your AWS Secret Access Key
   # Set default region (e.g., us-east-1)
   # Set default output format (e.g., json)
   #+end_src

3. Set the environment variable to use Bedrock:
   #+begin_src shell
   export CLAUDE_CODE_USE_BEDROCK=1
   #+end_src

*** Bedrock Model Access
:PROPERTIES:
:CUSTOM_ID: bedrock-model-access
:END:

Before using Claude via Bedrock, you need to request access to the Claude models:

1. Navigate to the Model Access page in Bedrock: 
   - https://us-east-1.console.aws.amazon.com/bedrock/home?region=us-east-1#/modelaccess

2. Request access to the Anthropic Claude models:
   - Select Claude 3 Opus, Claude 3 Sonnet, and Claude 3 Haiku
   - Click "Request model access"
   - Wait for approval (usually instant for most accounts)

3. Verify access by testing with the AWS CLI:
   #+begin_src shell
   aws bedrock list-foundation-models --region us-east-1 | grep -i claude
   #+end_src

*** Claude Code Configuration for Bedrock
:PROPERTIES:
:CUSTOM_ID: bedrock-config
:END:

Once you have access to the models, configure Claude Code to use Bedrock:

#+begin_src shell
# Set up environment for Bedrock use
export CLAUDE_CODE_USE_BEDROCK=1

# Or for permanent configuration:
echo 'export CLAUDE_CODE_USE_BEDROCK=1' >> ~/.bashrc
source ~/.bashrc

# Test the configuration
claude --version
#+end_src

You can also specify the model to use:

#+begin_src shell
claude --bedrock-model anthropic.claude-3-sonnet-20240229-v1:0
#+end_src

Refer to the official documentation for more details: https://docs.anthropic.com/en/docs/agents-and-tools/claude-code/overview#use-with-third-party-apis

*** Cost Management and Optimization
:PROPERTIES:
:CUSTOM_ID: cost-management
:END:

When using Bedrock, be aware of the cost implications:

1. Monitor usage through AWS Cost Explorer
2. Set up budget alerts to track Bedrock expenses
3. Use Claude 3 Haiku for less complex tasks to optimize costs
4. Leverage caching for repetitive operations

*** Exercise: Deploy Claude on Bedrock
:PROPERTIES:
:CUSTOM_ID: exercise-bedrock-deployment
:END:

In this exercise, you'll:
1. Configure your AWS credentials
2. Set up the required IAM permissions
3. Request and verify model access
4. Configure Claude Code to use Bedrock
5. Test the setup with a simple code analysis task

** Code Review and PR Workflows
:PROPERTIES:
:CUSTOM_ID: code-review-workflows
:END:

*** Code Review Best Practices
:PROPERTIES:
:CUSTOM_ID: code-review-best-practices
:END:

Claude Code excels at code review tasks. Here's how to leverage it effectively:

1. *Automated Code Quality Checks*:
   #+begin_src shell
   # Basic code review
   claude "Review this file for code quality, security issues, and best practices" src/auth.py
   
   # Focus on specific aspects
   claude "Check this function for potential security vulnerabilities" src/login.py:authenticate_user
   
   # Performance analysis
   claude "Analyze this algorithm for performance bottlenecks and suggest optimizations" algorithms/sort.py
   #+end_src

2. *Structured Review Templates*:
   #+begin_src shell
   claude "Review this PR and provide feedback in this format:
   ## Security Analysis
   - [List any security concerns]
   
   ## Code Quality
   - [Maintainability issues]
   - [Style violations]
   
   ## Performance
   - [Performance concerns]
   
   ## Suggested Improvements
   - [Specific actionable recommendations]"
   #+end_src

3. *Architecture and Design Reviews*:
   #+begin_src shell
   # High-level design review
   claude "Analyze this codebase architecture and suggest improvements"
   
   # Design pattern analysis
   claude "Identify design patterns used in this code and suggest alternatives if appropriate"
   #+end_src

*** PR Creation and Management
:PROPERTIES:
:CUSTOM_ID: pr-management
:END:

Streamline your PR workflow with Claude Code:

1. *Automated PR Descriptions*:
   #+begin_src shell
   # Generate PR description from git diff
   git diff main...feature-branch | claude "Create a comprehensive PR description based on these changes. Include:
   - Summary of changes
   - Testing approach
   - Breaking changes (if any)
   - Reviewer notes"
   #+end_src

2. *Commit Message Generation*:
   #+begin_src shell
   # Generate conventional commit messages
   git diff --staged | claude "Generate a conventional commit message for these staged changes"
   
   # Example output: "feat(auth): add OAuth2 integration with Google"
   #+end_src

3. *PR Review Automation*:
   #+begin_src shell
   # Review an entire PR
   gh pr diff 123 | claude "Review this PR for:
   1. Code quality and maintainability
   2. Potential bugs or edge cases
   3. Security considerations
   4. Testing completeness
   5. Documentation needs"
   #+end_src

4. *Merge Readiness Assessment*:
   #+begin_src shell
   # Check if PR is ready for merge
   claude "Assess if this PR is ready for merge based on:
   - Code quality
   - Test coverage
   - Documentation
   - Breaking changes
   - Security implications" < pr-diff.txt
   #+end_src

*** Code Summarization Techniques
:PROPERTIES:
:CUSTOM_ID: code-summarization
:END:

Effective code summarization helps with documentation and knowledge transfer:

1. *Function and Class Summaries*:
   #+begin_src shell
   # Summarize a complex function
   claude "Summarize this function's purpose, parameters, return value, and any side effects" src/complex_algorithm.py:process_data
   
   # Class overview
   claude "Provide a high-level overview of this class, its responsibilities, and main methods" src/user_manager.py:UserManager
   #+end_src

2. *Module and Package Summaries*:
   #+begin_src shell
   # Summarize an entire module
   claude "Create a module summary including purpose, main components, and usage examples" src/authentication.py
   
   # Package overview
   claude "Generate a README for this package based on the code structure and functionality" src/utils/
   #+end_src

3. *Codebase Architecture Summaries*:
   #+begin_src shell
   # High-level architecture overview
   claude "Analyze this codebase and create an architectural summary with:
   - Main components and their relationships
   - Data flow
   - Key design patterns
   - External dependencies"
   
   # Generate Mermaid diagrams
   claude "Create a Mermaid diagram showing the architecture of this system"
   #+end_src

4. *Change Impact Analysis*:
   #+begin_src shell
   # Analyze the impact of changes
   git diff main...feature | claude "Analyze the impact of these changes on:
   - Existing functionality
   - Performance
   - API compatibility
   - Dependencies"
   #+end_src

*** Exercise: Review and Summarize a PR
:PROPERTIES:
:CUSTOM_ID: exercise-pr-review
:END:

Practice using Claude Code for comprehensive PR review:

1. *Setup*:
   #+begin_src shell
   # Clone a sample repository
   git clone https://github.com/anthropics/claude-code
   cd claude-code
   
   # Find a recent PR to analyze
   gh pr list --limit 5
   #+end_src

2. *Tasks*:
   - Use Claude Code to review a PR for code quality
   - Generate a comprehensive PR summary
   - Create automated review comments
   - Assess merge readiness
   - Generate documentation based on the changes

3. *Deliverables*:
   - PR review report
   - Suggested improvements
   - Documentation updates
   - Security assessment

* Day 2: Advanced Claude Code Usage
:PROPERTIES:
:CUSTOM_ID: day-2
:END:

** Custom Claude Commands
:PROPERTIES:
:CUSTOM_ID: custom-commands
:END:

*** Command Structure and Syntax
:PROPERTIES:
:CUSTOM_ID: command-structure
:END:

Claude Code commands are structured prompts that can be reused and shared. Understanding their structure is key to creating effective custom commands.

1. *Basic Command Structure*:
   #+begin_src yaml
   # .claude/commands/analyze-security.yaml
   name: analyze-security
   description: Analyze code for security vulnerabilities
   prompt: |
     Please analyze the following code for security vulnerabilities. 
     Focus on:
     - SQL injection risks
     - XSS vulnerabilities  
     - Authentication bypasses
     - Input validation issues
     - Sensitive data exposure
     
     Provide specific recommendations for each issue found.
     
     Code to analyze:
     {selection}
   #+end_src

2. *Advanced Command Features*:
   #+begin_src yaml
   # .claude/commands/generate-docs.yaml
   name: generate-docs
   description: Generate comprehensive documentation
   prompt: |
     Generate comprehensive documentation for this code in the following format:
     
     ## Overview
     Brief description of what this code does
     
     ## Parameters
     List and describe all parameters
     
     ## Return Value
     Describe what the function/method returns
     
     ## Examples
     Provide practical usage examples
     
     ## Dependencies
     List any external dependencies
     
     Code: {selection}
   variables:
     - name: format
       description: Output format (markdown, rst, html)
       default: markdown
   #+end_src

3. *Command Categories and Organization*:
   #+begin_src shell
   # Organize commands by category
   .claude/commands/
   ├── analysis/
   │   ├── security-scan.yaml
   │   ├── performance-check.yaml
   │   └── code-quality.yaml
   ├── generation/
   │   ├── unit-tests.yaml
   │   ├── documentation.yaml
   │   └── api-endpoints.yaml
   └── refactoring/
       ├── optimize-functions.yaml
       ├── modernize-syntax.yaml
       └── extract-constants.yaml
   #+end_src

*** Creating Your First Command
:PROPERTIES:
:CUSTOM_ID: creating-commands
:END:

Let's create practical custom commands step by step:

1. *Set up the command directory*:
   #+begin_src shell
   # Create commands directory structure
   mkdir -p .claude/commands/analysis
   mkdir -p .claude/commands/generation
   mkdir -p .claude/commands/refactoring
   #+end_src

2. *Create a code review command*:
   #+begin_src yaml
   # .claude/commands/analysis/code-review.yaml
   name: code-review
   description: Comprehensive code review with actionable feedback
   prompt: |
     Please conduct a comprehensive code review of the following code. 
     Provide feedback in these categories:
     
     ## Code Quality
     - Readability and maintainability
     - Naming conventions
     - Code organization
     
     ## Performance
     - Potential bottlenecks
     - Optimization opportunities
     - Resource usage
     
     ## Security
     - Vulnerability assessment
     - Best practices compliance
     
     ## Testing
     - Test coverage adequacy
     - Suggested test cases
     
     ## Recommendations
     - Specific, actionable improvements
     - Priority ranking (High/Medium/Low)
     
     Code to review:
     {selection}
   #+end_src

3. *Create a test generation command*:
   #+begin_src yaml
   # .claude/commands/generation/unit-tests.yaml
   name: generate-tests
   description: Generate comprehensive unit tests
   prompt: |
     Generate comprehensive unit tests for the following code.
     
     Requirements:
     - Use pytest framework
     - Include positive and negative test cases
     - Test edge cases and error conditions
     - Add parametrized tests where appropriate
     - Include setup and teardown if needed
     - Add docstrings explaining test scenarios
     
     Original code:
     {selection}
   variables:
     - name: framework
       description: Testing framework to use
       default: pytest
   #+end_src

4. *Create a refactoring command*:
   #+begin_src yaml
   # .claude/commands/refactoring/optimize.yaml
   name: optimize-code
   description: Optimize code for performance and readability
   prompt: |
     Please optimize the following code for both performance and readability.
     
     Focus on:
     - Algorithm efficiency improvements
     - Memory usage optimization
     - Code clarity and structure
     - Removal of redundancy
     - Better error handling
     
     Provide both the optimized code and an explanation of changes made.
     
     Original code:
     {selection}
   #+end_src

5. *Using your custom commands*:
   #+begin_src shell
   # List available commands
   claude commands list
   
   # Use a custom command
   claude code-review src/authentication.py
   
   # Use command with selection
   claude generate-tests --selection "def calculate_fibonacci(n):"
   
   # Use command with variables
   claude generate-tests --framework unittest src/math_utils.py
   #+end_src

*** Command Distribution and Versioning
:PROPERTIES:
:CUSTOM_ID: command-distribution
:END:

Share and manage your custom commands effectively:

1. *Version Control Integration*:
   #+begin_src shell
   # Add commands to version control
   git add .claude/commands/
   git commit -m "feat: add custom Claude Code commands for code review and testing"
   
   # Create a commands repository
   git init claude-commands
   cd claude-commands
   cp -r ../.claude/commands/* .
   git add .
   git commit -m "initial: custom Claude Code commands collection"
   git remote add origin https://github.com/your-org/claude-commands.git
   git push -u origin main
   #+end_src

2. *Command Sharing and Import*:
   #+begin_src shell
   # Share commands via git repository
   git clone https://github.com/your-team/shared-claude-commands.git
   cp -r shared-claude-commands/* .claude/commands/
   
   # Or create a symbolic link for easier updates
   ln -s ~/shared-claude-commands/analysis .claude/commands/analysis
   #+end_src

3. *Command Validation and Testing*:
   #+begin_src shell
   # Test command syntax
   claude commands validate .claude/commands/analysis/code-review.yaml
   
   # Test command execution
   claude code-review --dry-run src/sample.py
   #+end_src

4. *Documentation and Metadata*:
   #+begin_src yaml
   # .claude/commands/metadata.yaml
   version: "1.0.0"
   author: "Development Team"
   description: "Custom commands for code analysis and generation"
   commands:
     - name: code-review
       category: analysis
       version: "1.2.0"
       last_updated: "2024-03-15"
     - name: generate-tests  
       category: generation
       version: "1.1.0"
       last_updated: "2024-03-10"
   #+end_src

*** Exercise: Build a Custom Command
:PROPERTIES:
:CUSTOM_ID: exercise-custom-command
:END:

Create a complete custom command workflow:

1. *Design Phase*:
   - Identify a repetitive task in your workflow
   - Define the command's scope and requirements
   - Plan the prompt structure and variables

2. *Implementation*:
   #+begin_src shell
   # Create your command directory
   mkdir -p .claude/commands/custom
   
   # Create a command for API documentation generation
   cat > .claude/commands/custom/api-docs.yaml << 'EOF'
   name: generate-api-docs
   description: Generate OpenAPI documentation from code
   prompt: |
     Generate OpenAPI 3.0 documentation for the following API code.
     
     Include:
     - Endpoint descriptions
     - Parameter schemas
     - Response schemas
     - Example requests/responses
     - Error codes and messages
     
     Format as valid OpenAPI YAML.
     
     Code:
     {selection}
   variables:
     - name: version
       description: API version
       default: "1.0.0"
   EOF
   #+end_src

3. *Testing and Refinement*:
   #+begin_src shell
   # Test the command
   claude generate-api-docs src/api/users.py
   
   # Refine based on results
   # Add more specific prompts or variables as needed
   #+end_src

4. *Integration*:
   - Add command to version control
   - Document usage for team members  
   - Create shortcuts or aliases for frequent use

** Model Context Protocol (MCP) Integration
:PROPERTIES:
:CUSTOM_ID: mcp-integration
:END:

*** Understanding MCP Architecture
:PROPERTIES:
:CUSTOM_ID: mcp-architecture
:END:

The Model Context Protocol (MCP) enables Claude Code to interact with external tools and data sources through a standardized protocol.

1. *MCP Core Concepts*:
   #+begin_src text
   Claude Code Client ←→ MCP Server ←→ External Service/Tool
                      (JSON-RPC over stdio/HTTP)
   #+end_src

   - *Client*: Claude Code acts as the MCP client
   - *Server*: Provides tools and resources to Claude
   - *Protocol*: JSON-RPC communication standard
   - *Tools*: Functions that Claude can call
   - *Resources*: Data sources Claude can access

2. *MCP Message Types*:
   #+begin_src json
   {
     "jsonrpc": "2.0",
     "method": "tools/list",
     "id": 1
   }
   
   {
     "jsonrpc": "2.0",
     "result": {
       "tools": [
         {
           "name": "search_database",
           "description": "Search the product database",
           "inputSchema": {
             "type": "object",
             "properties": {
               "query": {"type": "string"}
             }
           }
         }
       ]
     },
     "id": 1
   }
   #+end_src

3. *MCP Configuration Structure*:
   #+begin_src json
   {
     "mcpServers": {
       "filesystem": {
         "command": "npx",
         "args": ["-y", "@modelcontextprotocol/server-filesystem", "/path/to/allowed/files"]
       },
       "database": {
         "command": "python",
         "args": ["-m", "mcp_server_database"],
         "env": {
           "DATABASE_URL": "postgresql://localhost/mydb"
         }
       }
     }
   }
   #+end_src

*** Setting Up MCP Servers
:PROPERTIES:
:CUSTOM_ID: setting-up-mcp
:END:

Configure and deploy MCP servers for Claude Code integration:

1. *Install Common MCP Servers*:
   #+begin_src shell
   # Filesystem server for file operations
   npm install -g @modelcontextprotocol/server-filesystem
   
   # SQLite database server
   npm install -g @modelcontextprotocol/server-sqlite
   
   # Web search server
   npm install -g @modelcontextprotocol/server-brave-search
   
   # GitHub integration server
   npm install -g @modelcontextprotocol/server-github
   #+end_src

2. *Configure Claude Code with MCP Servers*:
   #+begin_src json
   # ~/.claude/mcp_servers.json
   {
     "mcpServers": {
       "filesystem": {
         "command": "npx",
         "args": [
           "-y", 
           "@modelcontextprotocol/server-filesystem",
           "/home/user/projects",
           "/home/user/documents"
         ]
       },
       "sqlite": {
         "command": "npx",
         "args": [
           "-y",
           "@modelcontextprotocol/server-sqlite",
           "--db-path",
           "/home/user/data/app.db"
         ]
       },
       "github": {
         "command": "npx",
         "args": ["-y", "@modelcontextprotocol/server-github"],
         "env": {
           "GITHUB_PERSONAL_ACCESS_TOKEN": "${GITHUB_TOKEN}"
         }
       }
     }
   }
   #+end_src

3. *Test MCP Server Configuration*:
   #+begin_src shell
   # Test filesystem access
   claude "List all Python files in the projects directory"
   
   # Test database queries
   claude "Show me the schema of the users table in the database"
   
   # Test GitHub integration
   claude "Show me recent issues in the main repository"
   #+end_src

4. *Environment-Specific Configuration*:
   #+begin_src shell
   # Development environment
   cp mcp_servers.dev.json ~/.claude/mcp_servers.json
   
   # Production environment with restricted access
   cp mcp_servers.prod.json ~/.claude/mcp_servers.json
   #+end_src

*** Building MCP-Aware Applications
:PROPERTIES:
:CUSTOM_ID: mcp-applications
:END:

Create applications that leverage MCP for enhanced functionality:

1. *Simple Python MCP Server*:
   #+begin_src python
   # custom_mcp_server.py
   import asyncio
   import json
   import sys
   from typing import Any, Dict, List
   
   from mcp.server.models import InitializationOptions
   from mcp.server import NotificationOptions, Server
   from mcp.types import Resource, Tool, TextContent, ImageContent, EmbeddedResource
   import mcp.types as types
   
   
   class CustomMCPServer:
       def __init__(self):
           self.server = Server("custom-server")
           self.setup_handlers()
   
       def setup_handlers(self):
           @self.server.list_tools()
           async def handle_list_tools() -> List[Tool]:
               return [
                   Tool(
                       name="calculate_fibonacci",
                       description="Calculate Fibonacci number at position n",
                       inputSchema={
                           "type": "object",
                           "properties": {
                               "n": {
                                   "type": "integer",
                                   "description": "Position in Fibonacci sequence"
                               }
                           },
                           "required": ["n"]
                       }
                   ),
                   Tool(
                       name="analyze_code_complexity",
                       description="Analyze code complexity metrics",
                       inputSchema={
                           "type": "object", 
                           "properties": {
                               "code": {
                                   "type": "string",
                                   "description": "Code to analyze"
                               }
                           },
                           "required": ["code"]
                       }
                   )
               ]
   
           @self.server.call_tool()
           async def handle_call_tool(name: str, arguments: Dict[str, Any]) -> List[types.TextContent]:
               if name == "calculate_fibonacci":
                   n = arguments.get("n", 0)
                   result = self.fibonacci(n)
                   return [types.TextContent(
                       type="text",
                       text=f"Fibonacci({n}) = {result}"
                   )]
               
               elif name == "analyze_code_complexity":
                   code = arguments.get("code", "")
                   complexity = self.analyze_complexity(code)
                   return [types.TextContent(
                       type="text", 
                       text=f"Code complexity analysis:\n{complexity}"
                   )]
               
               else:
                   raise ValueError(f"Unknown tool: {name}")
   
       def fibonacci(self, n: int) -> int:
           if n <= 1:
               return n
           return self.fibonacci(n-1) + self.fibonacci(n-2)
   
       def analyze_complexity(self, code: str) -> str:
           lines = len(code.split('\n'))
           chars = len(code)
           return f"Lines: {lines}, Characters: {chars}, Estimated complexity: {'High' if lines > 50 else 'Medium' if lines > 20 else 'Low'}"
   
       async def run(self):
           async with self.server as (read_stream, write_stream):
               await self.server.run(
                   read_stream,
                   write_stream,
                   InitializationOptions(
                       server_name="custom-server",
                       server_version="1.0.0",
                       capabilities=self.server.get_capabilities(
                           notification_options=NotificationOptions(),
                           experimental_capabilities={},
                       )
                   )
               )
   
   
   if __name__ == "__main__":
       server = CustomMCPServer()
       asyncio.run(server.run())
   #+end_src

2. *MCP Server Configuration*:
   #+begin_src json
   # Add to ~/.claude/mcp_servers.json
   {
     "mcpServers": {
       "custom": {
         "command": "python",
         "args": ["/path/to/custom_mcp_server.py"]
       }
     }
   }
   #+end_src

3. *Advanced MCP Features*:
   #+begin_src python
   # Advanced MCP server with resources and progress tracking
   @server.list_resources()
   async def handle_list_resources() -> List[Resource]:
       return [
           Resource(
               uri="file:///logs/application.log",
               name="Application Logs",
               description="Current application log file",
               mimeType="text/plain"
           ),
           Resource(
               uri="db://analytics/metrics",
               name="Performance Metrics", 
               description="Real-time performance metrics",
               mimeType="application/json"
           )
       ]
   
   @server.read_resource()
   async def handle_read_resource(uri: str) -> str:
       if uri == "file:///logs/application.log":
           with open("/var/log/app.log", "r") as f:
               return f.read()
       elif uri == "db://analytics/metrics":
           # Fetch from database
           metrics = get_performance_metrics()
           return json.dumps(metrics)
       else:
           raise ValueError(f"Unknown resource: {uri}")
   #+end_src

4. *Using MCP in Claude Code Workflows*:
   #+begin_src shell
   # Analyze code using custom MCP tools
   claude "Use the analyze_code_complexity tool to check the complexity of this function" src/algorithm.py:bubble_sort
   
   # Calculate values using MCP
   claude "Calculate fibonacci(20) using the custom MCP server"
   
   # Access resources through MCP
   claude "Read the application logs and summarize any errors"
   #+end_src

*** Exercise: Implement an MCP Server
:PROPERTIES:
:CUSTOM_ID: exercise-mcp-server
:END:

Build a complete MCP server for a specific use case:

1. *Project Setup*:
   #+begin_src shell
   # Create MCP server project
   mkdir claude-mcp-exercise
   cd claude-mcp-exercise
   
   # Set up Python environment
   python -m venv venv
   source venv/bin/activate
   pip install mcp
   #+end_src

2. *Implementation Tasks*:
   - Create an MCP server that provides code analysis tools
   - Implement tools for:
     - Code metrics calculation (lines, complexity, dependencies)
     - Security vulnerability scanning
     - Performance analysis suggestions
     - Test coverage assessment

3. *Server Features*:
   #+begin_src python
   # Required tools to implement:
   # 1. analyze_metrics(code: str) -> metrics report
   # 2. scan_security(code: str) -> security issues
   # 3. suggest_optimizations(code: str) -> performance tips
   # 4. check_test_coverage(code: str, tests: str) -> coverage report
   #+end_src

4. *Integration and Testing*:
   #+begin_src shell
   # Configure Claude Code to use your server
   # Test each tool individually
   # Create a comprehensive workflow demonstration
   #+end_src

5. *Documentation*:
   - Write clear documentation for each tool
   - Provide usage examples
   - Create troubleshooting guide
   - Document deployment instructions

** Best Practices from Anthropic
:PROPERTIES:
:CUSTOM_ID: best-practices
:END:

As outlined in [[https://www.anthropic.com/engineering/claude-code-best-practices][Anthropic's Claude Code Best Practices]] article, here are key strategies for effective usage:

*** Prompt Engineering for Claude Code
:PROPERTIES:
:CUSTOM_ID: prompt-engineering
:END:

Effective prompting can significantly improve Claude Code's output quality:

1. *Be Specific and Clear*:
   #+begin_src shell
   # Less effective:
   claude "Fix the bugs"
   
   # More effective:
   claude "Find and fix bugs in the authentication system, focusing on potential
   SQL injection vulnerabilities and improper error handling"
   #+end_src

2. *Include Context*:
   #+begin_src shell
   # Less effective:
   claude "Write a function to parse dates"
   
   # More effective:
   claude "Write a function to parse dates in ISO 8601 format (YYYY-MM-DD) and validate them.
   Handle edge cases like leap years and return a proper Date object if valid, 
   or throw a descriptive error if invalid"
   #+end_src

3. *Use Structured Formats*:
   #+begin_src shell
   claude "Review this code and provide feedback in the following format:
   1. Security issues (if any)
   2. Performance bottlenecks (if any)
   3. Maintainability concerns
   4. Suggested improvements with code examples"
   #+end_src

*** Security Considerations
:PROPERTIES:
:CUSTOM_ID: security-considerations
:END:

Best practices for secure usage of Claude Code:

1. *API Key Management*:
   - Use environment variables instead of hardcoding keys
   - Rotate keys periodically
   - Use different keys for development and production environments

2. *Code Review*:
   - Always review AI-generated code before executing or committing
   - Pay extra attention to security-sensitive areas like authentication and data validation
   - Use Claude Code to conduct security reviews of existing code

3. *Isolation Strategies*:
   - Consider using Docker containers for isolation (see the Docker section)
   - Limit network access where appropriate
   - Set up dedicated environments for Claude Code interactions

4. *Data Privacy*:
   - Be cautious about what code you share with Claude
   - Don't include sensitive credentials or personal data in prompts
   - Consider using the AWS Bedrock integration for enhanced data governance

*** Performance Optimization
:PROPERTIES:
:CUSTOM_ID: performance-optimization
:END:

Strategies to optimize Claude Code's performance and your workflow:

1. *Batching Related Tasks*:
   #+begin_src shell
   # Create a script file with multiple sequential tasks
   cat > batch-tasks.sh << 'EOF'
   claude "Review and optimize the authentication system"
   claude "Create unit tests for the optimized code"
   claude "Document the changes and create a PR description"
   EOF
   
   # Run the batched tasks
   bash batch-tasks.sh > results.md
   #+end_src

2. *Chunking Large Codebases*:
   - For large projects, analyze components separately
   - Use Claude to create a high-level overview first, then dive into specifics
   - Combine insights from multiple focused analyses

3. *Effective Iteration*:
   - Start with broad requests, then refine based on initial output
   - Use previous outputs as context for follow-up requests
   - Build on partial solutions rather than starting over

4. *Caching and History Management*:
   - Save useful Claude Code outputs for reference
   - Create templates for common tasks
   - Use version control to track AI-assisted changes

*** Exercise: Optimize Claude Code Usage
:PROPERTIES:
:CUSTOM_ID: exercise-optimization
:END:

In this hands-on exercise, you'll:
1. Create a script to batch multiple Claude Code tasks
2. Implement best practices for prompt engineering
3. Optimize a sample codebase using Claude Code
4. Document your approach and findings

Refer to the [[https://www.anthropic.com/engineering/claude-code-best-practices][Claude Code Best Practices]] article for additional guidance.

** Isolated Development with Docker
:PROPERTIES:
:CUSTOM_ID: isolated-development
:END:

For a clean, isolated development environment with Claude Code, you can use Docker:

*** Claude Code Docker Setup
:PROPERTIES:
:CUSTOM_ID: docker-setup
:END:

1. Create a ~Dockerfile~ for your isolated environment based on the official Claude Code dev container:

#+begin_src dockerfile
FROM node:20

ARG TZ
ENV TZ="$TZ"

# Install basic development tools and iptables/ipset
RUN apt update && apt install -y less \
  git \
  procps \
  sudo \
  fzf \
  zsh \
  man-db \
  unzip \
  gnupg2 \
  gh \
  iptables \
  ipset \
  iproute2 \
  dnsutils \
  aggregate \
  jq

# Ensure default node user has access to /usr/local/share
RUN mkdir -p /usr/local/share/npm-global && \
  chown -R node:node /usr/local/share

ARG USERNAME=node

# Persist bash history.
RUN SNIPPET="export PROMPT_COMMAND='history -a' && export HISTFILE=/commandhistory/.bash_history" \
  && mkdir /commandhistory \
  && touch /commandhistory/.bash_history \
  && chown -R $USERNAME /commandhistory

# Set `DEVCONTAINER` environment variable to help with orientation
ENV DEVCONTAINER=true

# Create workspace and config directories and set permissions
RUN mkdir -p /workspace /home/node/.claude && \
  chown -R node:node /workspace /home/node/.claude

WORKDIR /workspace

RUN ARCH=$(dpkg --print-architecture) && \
  wget "https://github.com/dandavison/delta/releases/download/0.18.2/git-delta_0.18.2_${ARCH}.deb" && \
  sudo dpkg -i "git-delta_0.18.2_${ARCH}.deb" && \
  rm "git-delta_0.18.2_${ARCH}.deb"

# Set up non-root user
USER node

# Install global packages
ENV NPM_CONFIG_PREFIX=/usr/local/share/npm-global
ENV PATH=$PATH:/usr/local/share/npm-global/bin

# Set the default shell to bash rather than sh
ENV SHELL /bin/zsh

# Default powerline10k theme
RUN sh -c "$(wget -O- https://github.com/deluan/zsh-in-docker/releases/download/v1.2.0/zsh-in-docker.sh)" -- \
  -p git \
  -p fzf \
  -a "source /usr/share/doc/fzf/examples/key-bindings.zsh" \
  -a "source /usr/share/doc/fzf/examples/completion.zsh" \
  -a "export PROMPT_COMMAND='history -a' && export HISTFILE=/commandhistory/.bash_history" \
  -x

# Install Claude
RUN npm install -g @anthropic-ai/claude-code

# Copy and set up firewall script
COPY init-firewall.sh /usr/local/bin/
USER root
RUN chmod +x /usr/local/bin/init-firewall.sh && \
  echo "node ALL=(root) NOPASSWD: /usr/local/bin/init-firewall.sh" > /etc/sudoers.d/node-firewall && \
  chmod 0440 /etc/sudoers.d/node-firewall
USER node
#+end_src

2. Create a ~docker-compose.yml~ file to define your services:

#+begin_src yaml
version: '3'
services:
  claude-code:
    build:
      context: .
      dockerfile: Dockerfile
    volumes:
      - .:/workspace
      - claude-config:/home/node/.claude
    environment:
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
    command: /bin/zsh
    
volumes:
  claude-config:
#+end_src

3. Build and start your container:

#+begin_src shell
# Build the container
docker-compose build

# Start the container
docker-compose up -d

# Connect to the container
docker-compose exec claude-code zsh
#+end_src

*** Benefits of Isolated Environment
:PROPERTIES:
:CUSTOM_ID: isolation-benefits
:END:

Using Docker for Claude Code development offers several advantages:

1. *Clean Environment*: Ensures all dependencies are correctly installed without conflicts
2. *Reproducibility*: Anyone can spin up the exact same environment
3. *Security*: Better isolation between Claude Code and your host system
4. *Portability*: Works across different operating systems
5. *Credential Management*: Environment variables are contained within the Docker environment

For more details, see the official [[https://github.com/anthropics/claude-code/blob/main/.devcontainer/Dockerfile][Claude Code Dev Container Dockerfile]].

* Resources and References
:PROPERTIES:
:CUSTOM_ID: resources
:END:

** Documentation Links
:PROPERTIES:
:CUSTOM_ID: documentation
:END:

Essential documentation for Claude Code:

- [[https://docs.anthropic.com/en/docs/agents-and-tools/claude-code/overview][Claude Code Overview]] - Official documentation on setup, configuration, and usage
- [[https://docs.anthropic.com/en/docs/agents-and-tools/claude-code/tutorials][Claude Code Tutorials]] - Practical examples and patterns for effectively using Claude Code
- [[https://docs.anthropic.com/en/docs/agents-and-tools/claude-code/overview#use-with-third-party-apis][Claude Code with Third-Party APIs]] - Guide for using Claude Code with Bedrock and other APIs
- [[https://docs.anthropic.com/en/docs/agents-and-tools/mcp][Model Context Protocol (MCP)]] - Documentation on the protocol that powers Claude Code
- [[https://www.anthropic.com/engineering/claude-code-best-practices][Claude Code Best Practices]] - Official blog post covering tips and tricks for effective usage

AWS Bedrock specific resources:
- [[https://us-east-1.console.aws.amazon.com/iam/home?region=us-east-2#/policies/details/arn%3Aaws%3Aiam%3A%3Aaws%3Apolicy%2FAmazonBedrockFullAccess][AmazonBedrockFullAccess Policy]] - IAM policy for Bedrock access
- [[https://us-east-1.console.aws.amazon.com/bedrock/home?region=us-east-1#/modelaccess][Bedrock Model Access Console]] - Request access to Claude models

GitHub authentication:
- [[https://github.com/settings/tokens/new][GitHub Personal Access Token Creation]] - Generate tokens for Claude Code

** Sample Code Repository
:PROPERTIES:
:CUSTOM_ID: sample-code
:END:

Practice with these sample repositories:

- [[https://github.com/anthropics/claude-code][Claude Code Repository]] - Official repository with examples and Dockerfiles
- [[https://github.com/anthropics/claude-code/blob/main/.devcontainer/Dockerfile][Claude Code Dev Container]] - Dockerfile for isolated development environments

** Troubleshooting Guide
:PROPERTIES:
:CUSTOM_ID: troubleshooting
:END:

Common issues and solutions:

*** Network and Download Issues
- Issue: "Could not download model-context-protocol"
  - Solution: Check your network connection and proxy settings
  - Try using a different network or disabling VPN
  - Verify that your firewall allows connections to Anthropic servers

*** Authentication Problems
- Issue: API key errors
  - Solution: Verify your key is correctly formatted and active
  - Check environment variables are properly set
  - Try regenerating your API key from the Anthropic console

*** GitHub Integration
- Issue: Unable to authenticate with GitHub
  - Solution: Verify your personal access token has the required scopes
  - Ensure GitHub CLI is properly installed
  - Try running `gh auth login` again with a new token

*** Bedrock Configuration
- Issue: "Invalid AWS credentials"
  - Solution: Run `aws configure` to set up your credentials
  - Verify your IAM user has the AmazonBedrockFullAccess policy
  - Check that you've requested access to Claude models in Bedrock

** Community Resources
:PROPERTIES:
:CUSTOM_ID: community
:END:

Connect with other Claude Code users:

- [[https://discord.gg/anthropic][Anthropic Discord]] - Official Discord server with Claude Code channels
- [[https://github.com/anthropics/claude-code/discussions][GitHub Discussions]] - Discuss features and share tips with the community
- [[https://news.ycombinator.com/item?id=43691230][Hacker News: Model Context Protocol Discussion]] - Community perspectives on MCP

* Exercises and Solutions
:PROPERTIES:
:CUSTOM_ID: exercises
:END:

** Day 1 Exercises
:PROPERTIES:
:CUSTOM_ID: day-1-exercises
:END:

*** Exercise 1.1: Basic Setup and Configuration
:PROPERTIES:
:CUSTOM_ID: exercise-1-1
:END:

*Objective*: Complete initial setup and verify Claude Code functionality

*Tasks*:
1. Install Claude Code CLI and verify installation
2. Configure API key (Anthropic or AWS Bedrock)
3. Set up GitHub authentication
4. Test basic commands

*Expected Output*:
#+begin_src shell
claude --version
# Should show version information

claude "Hello, analyze this simple Python function for improvements"
# Should provide code analysis
#+end_src

*** Exercise 1.2: Code Analysis and Review
:PROPERTIES:
:CUSTOM_ID: exercise-1-2
:END:

*Objective*: Practice using Claude Code for code review tasks

*Tasks*:
1. Clone a sample repository
2. Use Claude to analyze code quality
3. Generate a security assessment
4. Create improvement recommendations

*Sample Repository*:
#+begin_src shell
git clone https://github.com/anthropics/claude-code
cd claude-code/examples
#+end_src

*Commands to Practice*:
#+begin_src shell
# Analyze a specific file
claude "Review this file for code quality and security" src/example.py

# Generate PR description
git diff | claude "Create a comprehensive PR description"

# Security analysis
claude "Check for security vulnerabilities" src/auth.py
#+end_src

*** Exercise 1.3: AWS Bedrock Integration
:PROPERTIES:
:CUSTOM_ID: exercise-1-3
:END:

*Objective*: Configure and test Claude Code with AWS Bedrock

*Tasks*:
1. Set up AWS credentials and IAM permissions
2. Request model access in Bedrock console
3. Configure Claude Code for Bedrock usage
4. Test functionality with different Claude models

*Verification Commands*:
#+begin_src shell
# Test Bedrock configuration
export CLAUDE_CODE_USE_BEDROCK=1
claude "Test Bedrock integration with a simple query"

# Try different models
claude --bedrock-model anthropic.claude-3-haiku-20240307-v1:0 "Quick analysis"
#+end_src

** Day 2 Exercises
:PROPERTIES:
:CUSTOM_ID: day-2-exercises
:END:

*** Exercise 2.1: Custom Command Creation
:PROPERTIES:
:CUSTOM_ID: exercise-2-1
:END:

*Objective*: Create and deploy custom Claude commands

*Tasks*:
1. Design commands for your specific workflow
2. Implement commands with proper YAML structure
3. Test commands with real code examples
4. Share commands with team members

*Required Commands to Create*:
- Code review with custom criteria
- Test generation for specific framework
- Documentation generator for your project type
- Security scanner with organization-specific rules

*Template Structure*:
#+begin_src yaml
name: your-command
description: Clear description of what it does
prompt: |
  Detailed prompt with specific instructions
  
  Code to analyze:
  {selection}
variables:
  - name: framework
    description: Testing framework to use
    default: pytest
#+end_src

*** Exercise 2.2: MCP Server Development
:PROPERTIES:
:CUSTOM_ID: exercise-2-2
:END:

*Objective*: Build a functional MCP server for team use

*Project Requirements*:
- Implement at least 3 useful tools
- Include proper error handling
- Add comprehensive documentation
- Create configuration examples

*Suggested Tools to Implement*:
1. Code metrics analyzer
2. Dependency vulnerability scanner  
3. Performance benchmark runner
4. Test coverage reporter

*Deliverables*:
- Working MCP server code
- Configuration file for Claude Code
- Documentation with usage examples
- Test suite for the server

*** Exercise 2.3: End-to-End Workflow
:PROPERTIES:
:CUSTOM_ID: exercise-2-3
:END:

*Objective*: Create a complete development workflow using Claude Code

*Scenario*: You're tasked with reviewing and improving a legacy codebase

*Workflow Steps*:
1. Initial codebase analysis using Claude
2. Security vulnerability assessment
3. Performance optimization recommendations
4. Test coverage improvement
5. Documentation generation
6. PR creation with comprehensive description

*Tools to Use*:
- Custom commands for analysis
- MCP servers for data access
- Structured prompts for consistency
- Git integration for PR management

*Expected Deliverables*:
- Comprehensive analysis report
- Prioritized improvement recommendations
- Generated tests and documentation
- Ready-to-merge PR with clear description

** Solutions
:PROPERTIES:
:CUSTOM_ID: solutions
:END:

*** Exercise 1.1 Solution: Setup Verification
:PROPERTIES:
:CUSTOM_ID: solution-1-1
:END:

#+begin_src shell
# Installation verification script
#!/bin/bash

echo "=== Claude Code Setup Verification ==="

# Check installation
if command -v claude &> /dev/null; then
    echo "✓ Claude Code CLI installed"
    claude --version
else
    echo "✗ Claude Code CLI not found"
    echo "Install with: npm install -g @anthropic-ai/claude-code"
    exit 1
fi

# Check API configuration
if claude "test" --dry-run &> /dev/null; then
    echo "✓ API configuration working"
else
    echo "✗ API configuration issue"
    echo "Set ANTHROPIC_API_KEY or configure Bedrock"
fi

# Check GitHub authentication
if gh auth status &> /dev/null; then
    echo "✓ GitHub authentication configured"
else
    echo "⚠ GitHub authentication not configured"
    echo "Run: gh auth login"
fi

echo "Setup verification complete!"
#+end_src

*** Exercise 2.1 Solution: Custom Commands
:PROPERTIES:
:CUSTOM_ID: solution-2-1
:END:

#+begin_src yaml
# .claude/commands/analysis/comprehensive-review.yaml
name: comprehensive-review
description: Complete code review with security, performance, and quality analysis
prompt: |
  Conduct a comprehensive code review focusing on:
  
  ## Security Analysis
  - Authentication and authorization issues
  - Input validation vulnerabilities
  - Data exposure risks
  - Cryptographic implementation issues
  
  ## Performance Review
  - Algorithm efficiency (Big O analysis)
  - Memory usage patterns
  - I/O optimization opportunities
  - Caching strategies
  
  ## Code Quality Assessment
  - SOLID principles adherence
  - Code organization and structure
  - Naming conventions and clarity
  - Error handling completeness
  
  ## Testing Considerations
  - Test coverage gaps
  - Edge cases to consider
  - Mock/stub opportunities
  - Integration test needs
  
  Provide specific, actionable recommendations with priority levels.
  
  Code to review:
  {selection}
variables:
  - name: language
    description: Programming language for language-specific analysis
    default: python
  - name: focus
    description: Primary focus area (security, performance, quality, testing)
    default: all
#+end_src

*** Exercise 2.2 Solution: MCP Server Template
:PROPERTIES:
:CUSTOM_ID: solution-2-2
:END:

#+begin_src python
# solution_mcp_server.py
import asyncio
import json
import subprocess
from typing import Any, Dict, List

from mcp.server.models import InitializationOptions
from mcp.server import NotificationOptions, Server
from mcp.types import Tool, TextContent
import mcp.types as types


class CodeAnalysisMCPServer:
    def __init__(self):
        self.server = Server("code-analysis-server")
        self.setup_handlers()

    def setup_handlers(self):
        @self.server.list_tools()
        async def handle_list_tools() -> List[Tool]:
            return [
                Tool(
                    name="analyze_metrics",
                    description="Calculate code metrics including complexity and maintainability",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "code": {"type": "string", "description": "Source code to analyze"},
                            "language": {"type": "string", "description": "Programming language", "default": "python"}
                        },
                        "required": ["code"]
                    }
                ),
                Tool(
                    name="security_scan",
                    description="Scan code for common security vulnerabilities",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "code": {"type": "string", "description": "Source code to scan"},
                            "severity_threshold": {"type": "string", "enum": ["low", "medium", "high"], "default": "medium"}
                        },
                        "required": ["code"]
                    }
                ),
                Tool(
                    name="performance_analysis",
                    description="Analyze code for performance bottlenecks and optimization opportunities",
                    inputSchema={
                        "type": "object",
                        "properties": {
                            "code": {"type": "string", "description": "Source code to analyze"},
                            "focus": {"type": "string", "enum": ["memory", "cpu", "io", "all"], "default": "all"}
                        },
                        "required": ["code"]
                    }
                )
            ]

        @self.server.call_tool()
        async def handle_call_tool(name: str, arguments: Dict[str, Any]) -> List[types.TextContent]:
            if name == "analyze_metrics":
                return await self.analyze_metrics(arguments)
            elif name == "security_scan":
                return await self.security_scan(arguments)
            elif name == "performance_analysis":
                return await self.performance_analysis(arguments)
            else:
                raise ValueError(f"Unknown tool: {name}")

    async def analyze_metrics(self, args: Dict[str, Any]) -> List[types.TextContent]:
        code = args.get("code", "")
        language = args.get("language", "python")
        
        # Calculate basic metrics
        lines = len(code.split('\n'))
        chars = len(code)
        functions = code.count('def ') if language == 'python' else code.count('function ')
        classes = code.count('class ') if language == 'python' else 0
        
        # Estimate complexity
        complexity_indicators = ['if ', 'for ', 'while ', 'try ', 'except ', 'elif ']
        complexity_score = sum(code.count(indicator) for indicator in complexity_indicators)
        
        report = f"""
Code Metrics Analysis:
- Lines of code: {lines}
- Characters: {chars}
- Functions: {functions}
- Classes: {classes}
- Complexity score: {complexity_score}
- Complexity level: {'High' if complexity_score > 20 else 'Medium' if complexity_score > 10 else 'Low'}

Recommendations:
- {'Consider breaking down complex functions' if complexity_score > 20 else 'Complexity is manageable'}
- {'Add more documentation' if lines > 100 and '"""' not in code else 'Documentation appears adequate'}
"""
        
        return [types.TextContent(type="text", text=report)]

    async def security_scan(self, args: Dict[str, Any]) -> List[types.TextContent]:
        code = args.get("code", "")
        threshold = args.get("severity_threshold", "medium")
        
        issues = []
        
        # Check for common security issues
        if 'eval(' in code:
            issues.append("HIGH: Use of eval() function detected - potential code injection risk")
        
        if 'exec(' in code:
            issues.append("HIGH: Use of exec() function detected - potential code injection risk")
        
        if 'password' in code.lower() and ('=' in code or 'input(' in code):
            issues.append("MEDIUM: Potential hardcoded password or password handling issue")
        
        if 'sql' in code.lower() and ('+' in code or f'f"' in code):
            issues.append("HIGH: Potential SQL injection vulnerability")
        
        if not issues:
            issues.append("No obvious security issues detected")
        
        report = f"""
Security Scan Results (threshold: {threshold}):

Issues Found:
{''.join(f'- {issue}' for issue in issues)}

Recommendations:
- Use parameterized queries for database operations
- Avoid eval() and exec() functions
- Store secrets in environment variables
- Implement proper input validation
"""
        
        return [types.TextContent(type="text", text=report)]

    async def performance_analysis(self, args: Dict[str, Any]) -> List[types.TextContent]:
        code = args.get("code", "")
        focus = args.get("focus", "all")
        
        suggestions = []
        
        # Basic performance analysis
        if 'for ' in code and 'in range(' in code and '.append(' in code:
            suggestions.append("Consider using list comprehensions instead of append in loops")
        
        if code.count('import ') > 10:
            suggestions.append("Consider lazy imports to improve startup time")
        
        if 'time.sleep(' in code:
            suggestions.append("Review sleep() usage - consider async alternatives")
        
        if '**' in code:
            suggestions.append("Power operations can be expensive - consider alternatives for simple cases")
        
        if not suggestions:
            suggestions.append("No obvious performance issues detected")
        
        report = f"""
Performance Analysis (focus: {focus}):

Optimization Opportunities:
{''.join(f'- {suggestion}' for suggestion in suggestions)}

General Recommendations:
- Profile code to identify actual bottlenecks
- Consider caching for expensive operations
- Use appropriate data structures for your use case
- Implement connection pooling for database operations
"""
        
        return [types.TextContent(type="text", text=report)]

    async def run(self):
        async with self.server as (read_stream, write_stream):
            await self.server.run(
                read_stream,
                write_stream,
                InitializationOptions(
                    server_name="code-analysis-server",
                    server_version="1.0.0",
                    capabilities=self.server.get_capabilities(
                        notification_options=NotificationOptions(),
                        experimental_capabilities={},
                    )
                )
            )


if __name__ == "__main__":
    server = CodeAnalysisMCPServer()
    asyncio.run(server.run())
#+end_src

* Appendix
:PROPERTIES:
:CUSTOM_ID: appendix
:END:

** Glossary
:PROPERTIES:
:CUSTOM_ID: glossary
:END:

*** Core Terms
:PROPERTIES:
:CUSTOM_ID: core-terms
:END:

- *Claude Code*: Anthropic's official CLI tool for AI-assisted development
- *MCP (Model Context Protocol)*: Standardized protocol for connecting AI models to external tools and data sources
- *Custom Commands*: User-defined structured prompts for specific tasks
- *Bedrock*: AWS service providing access to Claude models through managed infrastructure
- *Tool*: A function that Claude can call through MCP to perform specific actions
- *Resource*: Data source that Claude can access through MCP (files, databases, APIs)
- *Prompt Engineering*: Crafting effective prompts to get optimal responses from Claude

*** Technical Terms
:PROPERTIES:
:CUSTOM_ID: technical-terms
:END:

- *JSON-RPC*: Remote procedure call protocol used by MCP for communication
- *stdin/stdout*: Standard input/output streams used for MCP communication
- *API Key*: Authentication token for accessing Anthropic's services
- *IAM (Identity and Access Management)*: AWS service for managing permissions
- *CLI (Command Line Interface)*: Text-based interface for interacting with software
- *SDK (Software Development Kit)*: Set of tools for developing applications with a service

** Configuration Templates
:PROPERTIES:
:CUSTOM_ID: config-templates
:END:

*** Basic Claude Code Configuration
:PROPERTIES:
:CUSTOM_ID: basic-config
:END:

#+begin_src json
# ~/.claude/config.json
{
  "api_key": "${ANTHROPIC_API_KEY}",
  "model": "claude-3-sonnet-20240229",
  "max_tokens": 4000,
  "temperature": 0.1
}
#+end_src

*** MCP Server Configuration
:PROPERTIES:
:CUSTOM_ID: mcp-config
:END:

#+begin_src json
# ~/.claude/mcp_servers.json
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/allowed/path"]
    },
    "sqlite": {
      "command": "npx", 
      "args": ["-y", "@modelcontextprotocol/server-sqlite", "--db-path", "/path/to/database.db"]
    },
    "github": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-github"],
      "env": {
        "GITHUB_PERSONAL_ACCESS_TOKEN": "${GITHUB_TOKEN}"
      }
    },
    "custom": {
      "command": "python",
      "args": ["/path/to/custom_server.py"],
      "env": {
        "CUSTOM_CONFIG": "/path/to/config.json"
      }
    }
  }
}
#+end_src

*** AWS Bedrock Configuration
:PROPERTIES:
:CUSTOM_ID: bedrock-config
:END:

#+begin_src shell
# Environment variables for Bedrock
export CLAUDE_CODE_USE_BEDROCK=1
export AWS_REGION=us-east-1
export AWS_ACCESS_KEY_ID=your_access_key
export AWS_SECRET_ACCESS_KEY=your_secret_key

# Or use AWS CLI configuration
aws configure set region us-east-1
aws configure set aws_access_key_id your_access_key
aws configure set aws_secret_access_key your_secret_key
#+end_src

*** Docker Development Environment
:PROPERTIES:
:CUSTOM_ID: docker-config
:END:

#+begin_src yaml
# docker-compose.yml
version: '3.8'
services:
  claude-code:
    build:
      context: .
      dockerfile: Dockerfile
    volumes:
      - .:/workspace
      - claude-config:/home/node/.claude
      - ~/.gitconfig:/home/node/.gitconfig:ro
    environment:
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - GITHUB_TOKEN=${GITHUB_TOKEN}
    working_dir: /workspace
    command: /bin/zsh

volumes:
  claude-config:
#+end_src

** Further Reading
:PROPERTIES:
:CUSTOM_ID: further-reading
:END:

*** Official Documentation
:PROPERTIES:
:CUSTOM_ID: official-docs
:END:

- [[https://docs.anthropic.com/en/docs/claude-code][Claude Code Documentation]] - Comprehensive official documentation
- [[https://docs.anthropic.com/en/docs/mcp][Model Context Protocol Specification]] - Technical specification for MCP
- [[https://www.anthropic.com/engineering/claude-code-best-practices][Claude Code Best Practices]] - Official engineering blog post
- [[https://docs.anthropic.com/en/api][Anthropic API Documentation]] - API reference for direct integration

*** Advanced Topics
:PROPERTIES:
:CUSTOM_ID: advanced-topics
:END:

- [[https://github.com/anthropics/claude-code][Claude Code GitHub Repository]] - Source code and examples
- [[https://github.com/modelcontextprotocol][MCP GitHub Organization]] - MCP servers and tools
- [[https://docs.aws.amazon.com/bedrock/][AWS Bedrock Documentation]] - Bedrock service documentation
- [[https://github.com/anthropics/claude-code/tree/main/.devcontainer][Dev Container Configuration]] - Advanced Docker setup

*** Community Resources
:PROPERTIES:
:CUSTOM_ID: community-resources
:END:

- [[https://discord.gg/anthropic][Anthropic Discord Server]] - Community discussions and support
- [[https://github.com/anthropics/claude-code/discussions][GitHub Discussions]] - Feature requests and community Q&A
- [[https://docs.anthropic.com/en/docs/build-with-claude][Build with Claude]] - Tutorials and examples for developers
- [[https://www.anthropic.com/research][Anthropic Research]] - Latest research papers and findings

*** Integration Examples
:PROPERTIES:
:CUSTOM_ID: integration-examples
:END:

- [[https://github.com/anthropics/mcp-examples][MCP Examples Repository]] - Sample MCP server implementations
- [[https://docs.anthropic.com/en/docs/claude-code/tutorials][Claude Code Tutorials]] - Step-by-step integration guides
- [[https://github.com/anthropics/claude-code/tree/main/examples][Claude Code Examples]] - Real-world usage examples
- [[https://www.anthropic.com/engineering][Anthropic Engineering Blog]] - Technical deep dives and case studies